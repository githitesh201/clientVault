---
title: Comandi Backend
---

## Comandi utili

Questi comandi devono essere eseguiti dalla cartella packages/clientvault-server.
Da qualsiasi altra cartella puoi eseguire `npx nx {command} clientvault-server` (oppure `npx nx run clientvault-server:{command}`).

### Impostazione iniziale

```
npx nx database:reset clientvault-server # configura il database con dati di esempio per lo sviluppo
```

### Avvio del server

```
npx nx run clientvault-server:start
```

### Lint

```
npx nx run clientvault-server:lint # passa --fix per correggere gli errori di lint
```

### Test

```
npx nx run clientvault-server:test:unit          # esegui test unitari
npx nx run clientvault-server:test:integration   # esegui test di integrazione
```

Nota: puoi eseguire `npx nx run clientvault-server:test:integration:with-db-reset` nel caso in cui sia necessario resettare il database prima di eseguire i test di integrazione.

### Ripristino del database

Se vuoi resettare e seminare il database, puoi eseguire il seguente comando:

```bash
npx nx run clientvault-server:database:reset
```

### Migrazioni

#### Per oggetti negli schemi Core/Metadata (TypeORM)

```bash
npx nx run clientvault-server:typeorm migration:generate src/database/typeorm/core/migrations/nameOfYourMigration -d src/database/typeorm/core/core.datasource.ts
```

#### Per gli oggetti del Workspace

Non ci sono file di migrazioni; le migrazioni sono generate automaticamente per ogni workspace, memorizzate nel database e applicate con questo comando

```bash
npx nx run clientvault-server:command workspace:sync-metadata -f
```

<Warning>
  Questo eliminerà il database e rieseguirà le migrazioni e il popolamento dei dati.

  Assicurati di eseguire il backup dei dati che vuoi mantenere prima di eseguire questo comando.
</Warning>

## Tech Stack

ClientVault utilizza principalmente NestJS per il backend.

Prisma è stato il primo ORM che abbiamo usato. Ma per permettere agli utenti di creare campi personalizzati e oggetti personalizzati, un livello più basso aveva più senso poiché abbiamo bisogno di avere un controllo granulare. Il progetto ora utilizza TypeORM.

Ecco come appare ora lo stack tecnologico.

**Core**

* [NestJS](https://nestjs.com/)
* [TypeORM](https://typeorm.io/)
* [GraphQL Yoga](https://the-guild.dev/graphql/yoga-server)

**Database**

* [Postgres](https://www.postgresql.org/)

**Integrazioni di terze parti**

* [Sentry](https://sentry.io/welcome/) per il tracciamento degli errori

**Testing**

* [Jest](https://jestjs.io/)

**Strumenti**

* [Yarn](https://yarnpkg.com/)
* [ESLint](https://eslint.org/)

**Sviluppo**

* [AWS EKS](https://aws.amazon.com/eks/)
